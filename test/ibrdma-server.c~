#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <rdma/rdma_cma.h>

#define TEST_NZ(x) do { if ( (x)) die("error: " #x " failed (returned non-zero." ); } while (0)
#define TEST_Z(x)  do { if (!(x)) die("error: " #x " failed (returned non-zero." ); } while (0)

static void on_event(struct rdma_cm_event *event);

static void on_connect_request(struct rdma_cm_id *id);
static void on_connection(void *context);
static void on_disconnect(struct rdma_cm_id *id);


static void die(const char *reason);

int main (int argc, char **reason)
{
  /*
  struct sockaddr_in{
   short sin_family;
   unsigned short sin_port;
   struct in_addr sin_addr;
   char sin_zero[8];
  };
   */
  struct sockaddr_in addr;

  
  struct rdma_cm_event *event = NULL;


  /*
  struct rdma_cm_id {
    struct ib_device        *device;
    void                    *context;
    struct ib_qp            *qp;
    rdma_cm_event_handler    event_handler;
    struct rdma_route        route;
    enum rdma_port_space     ps;
    enum ib_qp_type          qp_type;
    u8                       port_num;
   };
  */
  struct rdma_cm_id *listener = NULL;
  struct rdma_event_channel *ec = NULL;
  uint16_t port = 0;

  // By setting addr.sin_port to zero, 
  //we instruct rdmacm to pick an available port
  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;

  // 1. Create an event channel so that we can receive rdmacm events, 
  // such as connection-request and connection-established notifications.
  TEST_Z(ec = rdma_create_event_channel());

  // 2. Create a listener
  TEST_NZ(rdma_create_id(ec, &listener, NULL, RDMA_PS_TCP));

  // 3. Bind to an address and get the address/port
  TEST_NZ(rdma_bind_addr(listener, (struct sockaddr *) &addr));
  port = ntohs(rdma_get_src_port(listener));

  // 4. Wait for a connection request.
  printf("listening on port %d.\n", port);
  while (rdma_get_cm_event(ec, &event) == 0) {
    struct rdma_cm_event event_copy;
    memcpy(&event_copy, event, sizeof(*event));
    rdma_ack_cm_event(event);
    if (on_event(&event_copy))
      break;
  }

  rdma_destroy_id(listener);
  rdma_destroy_event_channel(ec);
//  5. Create a protection domain, completion queue, and send-receive queue pair.
//   6. Accept the connection request.
//   7. Wait for the connection to be established.
//  8. Post operations as appropriate.


  return 0;
}

void die(const char *reason)
{
  fprintf(stderr, "%s\n", reason);
  exit(EXIT_FAILURE);
}
